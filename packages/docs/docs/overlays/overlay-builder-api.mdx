---
sidebar_position: 2
title: Overlay Builder API
---

This page documents the overlay authoring APIs:

- `builder.overlay(...)`
- `OverlayBuilder` (callback form)

Overlays are **data-only specs** (`VizOverlaySpec`) rendered by the overlay registry.

---

## `builder.overlay(...)`

There are two recommended ways to add overlays:

### 1) Direct form: `builder.overlay(id, params, key?)`

```ts
builder.overlay('signal', { from: 'a', to: 'b', progress: 0.5 }, 'sig');
```

- `id: string` — overlay kind
- `params: unknown` — overlay parameters
- `key?: string` — stable key (recommended)

**Typing**

Built-in overlay ids are type-safe (via `OverlayKindRegistry`), so you’ll get autocomplete and param type-checking for ids like:

- `"signal"`
- `"grid-labels"`
- `"data-points"`

Unknown/custom ids are allowed (backwards compatible), but their params are `unknown`.

### 2) Callback form: `builder.overlay((o) => ...)`

Use this when you want to add multiple overlays at once (and optionally remove/clear within the callback).

```ts
builder.overlay((o) =>
  o
    .add('grid-labels', { colLabels: { 0: '0' } }, { key: 'labels' })
    .add('signal', { from: 'a', to: 'b', progress: 0 }, { key: 'sig' })
);
```

Under the hood, VizCraft creates an `OverlayBuilder`, passes it to your callback, then appends the resulting `VizOverlaySpec[]` to the builder’s scene overlays.

---

## `OverlayBuilder`

You can import it as:

```ts
import { OverlayBuilder } from 'vizcraft';
```

…but in typical usage you’ll receive it as the `o` argument in `builder.overlay((o) => ...)`.

### `o.add(id, params, options?)`

Adds an overlay spec.

- `id: string` — overlay kind
- `params` — overlay params
- `options?: { key?: string; className?: string }`

**Keys and collisions**

Overlays reconcile by `key || id`. If you add multiple overlays with the same `id` and no keys, they would collide.

To keep things ergonomic, `OverlayBuilder.add(...)` will auto-generate keys when it detects multiple unkeyed overlays of the same `id`:

- first unkeyed: `key` stays `undefined`
- second unkeyed of same id: gets `"<id>#1"`
- third unkeyed: gets `"<id>#2"`

If you want to animate an overlay later, you should still provide an explicit `key` so you can target it deterministically.

### `o.remove(keyOrId)`

Removes overlays by:

- key (always), or
- id only for unkeyed overlays

```ts
builder.overlay((o) => {
  o.add('signal', { from: 'a', to: 'b', progress: 0.2 }, { key: 'sig' });
  o.remove('sig');
});
```

### `o.clear()`

Removes all overlay specs accumulated in the `OverlayBuilder`.

### `o.build()`

Returns a shallow copy of the accumulated `VizOverlaySpec[]`.

---

## Animating overlays

Overlays integrate with the **data-only timeline** animation system.

### Target selection: `aBuilder.overlay(key)`

This targets an overlay instance by key:

- target form: `overlay:<key>`

Example:

```ts
builder.overlay('signal', { from: 'a', to: 'b', progress: 0 }, 'sig');

builder.animate((aBuilder) => {
  aBuilder.overlay('sig');
  aBuilder.to({ progress: 1 }, { duration: 900, easing: 'easeInOut' });
});
```

### What properties are animatable?

Any numeric property in `spec.params` can be tweened.

- If a value is not numeric (or is `NaN`), it’s ignored.
- During playback, VizCraft updates `spec.params[prop]` each frame and patches the mounted overlay DOM.

---

## Extending overlay typing (advanced)

If you create a custom overlay kind and want it to be type-safe, augment the `OverlayKindRegistry`.

```ts
// Somewhere in your app/library
declare module 'vizcraft' {
  interface OverlayKindRegistry {
    selection: { x: number; y: number; w: number; h: number };
  }
}
```

Now TypeScript will type-check:

```ts
builder.overlay('selection', { x: 10, y: 10, w: 120, h: 80 }, 'sel');
```

---

## Built-in primitive overlays (no custom registry needed)

VizCraft includes a few generic overlay kinds in the default registry, which lets you create “new” overlays without writing a renderer:

- `rect`: `{ x, y, w, h, rx?, ry?, opacity? }`
- `circle`: `{ x, y, r, opacity? }`
- `text`: `{ x, y, text, opacity?, fontSize?, fontWeight?, textAnchor?, dominantBaseline? }`

These primitives are especially useful for quick annotations and selection UI.

### Convenience methods

When using the callback form (`builder.overlay((o) => ...)`), you can use:

- `o.rect(params, options?)`
- `o.circle(params, options?)`
- `o.text(params, options?)`

They compile to `.add('rect' | 'circle' | 'text', ...)`.
