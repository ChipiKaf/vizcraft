---
sidebar_position: 4
title: Advanced
---

import { viz } from 'vizcraft';

import CodePreview from '@site/src/components/CodePreview';
import VizMount from '@site/src/components/VizMount';
import ResizeDemo from '@site/src/components/ResizeDemo';
import MutationDemo from '@site/src/components/MutationDemo';
import ZOrderingDemo from '@site/src/components/ZOrderingDemo';

export const interactiveBuilder = viz().view(400, 200);
export const interactiveScene = interactiveBuilder
  .node('btn')
  .at(200, 100)
  .rect(120, 50, 10)
  .label('Click Me')
  .class('interactive-node')
  .onClick((id) => alert(`Clicked node ${id}`))
  .done();

export const selfLoopBuilder = viz().view(400, 200);
export const selfLoopScene = selfLoopBuilder
  .node('db')
  .at(200, 100)
  .cylinder(80, 60)
  .fill('#fab387')
  .label('Database')
  .done()
  .edge('db', 'db')
  .loopSide('right')
  .loopSize(60)
  .arrow()
  .label('Ping', { position: 'mid', dy: 0, dx: -32 })
  .done();

Take your visualizations to the next level with animations and interactivity.

## Animations

Animations now have their own dedicated guide:

- See: [Animations](./animations)

## Interactivity

You can handle click events on nodes and edges.

<CodePreview code={`
import { viz } from 'vizcraft';

const builder = viz().view(400, 200);

builder
.node('btn')
.at(200, 100)
.rect(120, 50, 10)
.label('Click Me')
.class('interactive-node')
.onClick((id) => alert(\`Clicked node \${id}\`))
.done();

const container = document.getElementById('viz-interactive');
if (container) builder.mount(container);
`}>

  <VizMount
    builder={interactiveScene}
    style={{ height: '200px', width: '100%' }}
  />
</CodePreview>

:::info
Interactive elements will automatically get `cursor: pointer` if an `onClick` handler is attached, but you can also enforce it via styles.
:::

## Self-Loop Edges

Self-loop edges are edges that connect a node to itself. They are drawn using bezier curves extending outward from the node boundaries.

Use the fluent \`.loopSide()\` and \`.loopSize()\` methods to control the placement and extension of the loop curve.

<CodePreview code={`
import { viz } from 'vizcraft';

const builder = viz().view(400, 200);

builder
  .node('db')
  .at(200, 100)
  .cylinder(80, 60)
  .fill('#fab387')
  .label('Database')
  .done()
  .edge('db', 'db')
  .loopSide('right')
  .loopSize(60)
  .arrow()
  .label('Ping', { position: 'mid', dy: 0, dx: -32 })
  .done();

const container = document.getElementById('viz-self-loop');
if (container) builder.mount(container);
`}>

  <VizMount
    builder={selfLoopScene}
    style={{ height: '200px', width: '100%' }}
  />
</CodePreview>

## Runtime Node Resizing

You can interactively change the width, height, and radius of a node at runtime without doing a full DOM reconciliation. Calling `builder.resizeNode()` followed by `builder.patchRuntime()` updates the SVG path and intelligently adjusts the geometric connection points of any edges pointing to or coming from that node.

<CodePreview>
  <ResizeDemo />
</CodePreview>

```ts
import { viz } from 'vizcraft';

const builder = viz()
  .view(400, 200)
  .node('dynamic', { rect: { w: 100, h: 50 }, at: { x: 200, y: 100 } })
  .node('left', { circle: { r: 20 }, at: { x: 50, y: 100 } })
  .edge('left', 'dynamic', { arrow: true });

// Initial mount
const container = document.getElementById('viz');
builder.mount(container);

// Later, interactively resize node 'dynamic' and apply patches directly
builder.resizeNode('dynamic', { w: 180, h: 80 });
builder.patchRuntime(container);
```

## Incremental Scene Updates

Vizcraft allows you to incrementally add, update, and remove nodes and edges at runtime using the `VizSceneMutator` methods (`addNode`, `updateNode`, `removeNode`, etc.). Calling `builder.commit(container)` gracefully syncs these mutations to the DOM and runtime overrides without total DOM thrashing.

<CodePreview>
  <MutationDemo />
</CodePreview>

```ts
import { viz } from 'vizcraft';

const builder = viz()
  .view(600, 300)
  .node('root', { circle: { r: 30 }, at: { x: 100, y: 150 } });

// Mount the initial view
const container = document.getElementById('viz');
builder.mount(container, { panZoom: true });

// Later, you can imperatively mutate the scene!
builder.addNode({
  id: 'n1',
  pos: { x: 250, y: 150 },
  shape: { kind: 'rect', w: 80, h: 40 },
});
builder.addEdge({ id: 'e1', from: 'root', to: 'n1', arrow: 'end' });
builder.commit(container);
```

## Node Z-Ordering

Controlling the stack order of objects on the grid is important when multiple nodes intersect. By default, visual order is determined by SVG insertion order. You can easily control this dynamically using the \`zIndex\` property on nodes or options.

<CodePreview>
  <ZOrderingDemo />
</CodePreview>

```ts
import { viz } from 'vizcraft';

const builder = viz()
  .view(600, 300)
  .node('back', { circle: { r: 50 }, at: { x: 250, y: 150 }, zIndex: 1, fill: 'blue' })
  .node('front', { circle: { r: 50 }, at: { x: 300, y: 150 }, zIndex: 5, fill: 'green' })
  .node('dynamic', { circle: { r: 60 }, at: { x: 275, y: 100 }, zIndex: 0, fill: 'red' });

const container = document.getElementById('viz');
builder.mount(container);

// Later, interactively bring the dynamic node to the front
builder.node('dynamic', { zIndex: 10 });
builder.patchRuntime(container);
```

## Plugins

VizCraft features a lightweight plugin system, allowing you to seamlessly extend its functionality without bloating the core library itself. Plugins are functions that accept a `VizBuilder` instance and can mutate the scene, register custom behaviors, or execute utilities like exporting.

<CodePreview>
```ts
import { viz, VizPlugin } from 'vizcraft';

// A simple plugin that adds a watermark to the scene
const watermarkPlugin: VizPlugin<{ text: string }> = (builder, options) => {
  builder.node('watermark', {
    at: { x: 50, y: 50 },
    rect: { w: 100, h: 30 },
    label: options?.text ?? 'Watermark',
    zIndex: 999,
    opacity: 0.5
  });
};

const builder = viz().view(400, 200);

builder
  .node('a', { circle: { r: 20 }, at: { x: 150, y: 100 } })
  // Attach the plugin fluently
  .use(watermarkPlugin, { text: 'Draft Version' });

// const container = document.getElementById('viz');
// if (container) builder.mount(container);
```
</CodePreview>

### Event Hooks

Plugins become incredibly powerful when combined with lifecycle event hooks. You can use the `builder.on()` method to listen for the `'build'` and `'mount'` events.

For example, an export plugin could wait for VizCraft to mount the SVG to the DOM, and then inject a floating "Download as PNG" button directly into the container element:

```ts
const exportUiPlugin: VizPlugin = (builder) => {
  builder.on('mount', ({ container, controller }) => {
     const btn = document.createElement('button');
     btn.innerText = "Download PNG";
     btn.onclick = () => { 
        // Logic to export the builder.svg() string to PNG
     };
     
     btn.style.position = 'absolute';
     btn.style.top = '10px';
     btn.style.right = '10px';
     container.appendChild(btn);
  });
};
```

See the [types documentation](./types#vizplugin) for details on the `VizPlugin` signature.

# Viewport & Pan/Zoom

As your diagrams grow larger, a fixed-size SVG isn't always enough to comfortably display all content. VizCraft includes a built-in pan & zoom viewport controller to make exploring large scenes intuitive.

## Enabling Pan & Zoom

You can enable interactive pan and zoom across the `VizScene` by passing the `panZoom: true` flag in the mounting options.

When `panZoom` is activated, interactions work out-of-the-box:

- **Scroll wheel / trackpad** to zoom in and out.
- **Click and drag** on empty background space to pan the diagram.
- **Double click** on empty background space to auto-fit the scene to the viewport.

<CodePreview>
  <VizMount
    className="border border-solid border-gray-200 dark:border-gray-800 rounded-lg shadow-sm"
    style={{ height: '400px', cursor: 'grab', overflow: 'hidden' }}
    panZoom={true}
    builder={viz()
      .view(800, 600)

      // Background node
      .node('bg', {
        rect: { w: 600, h: 400, rx: 20 },
        at: { x: 400, y: 300 },
        fill: 'var(--ifm-color-emphasis-100)',
        stroke: { color: 'var(--ifm-color-emphasis-300)', width: 2 },
      })

      // Define some colorful shapes spread out in the canvas
      .node('a', {
        circle: { r: 40 },
        at: { x: 200, y: 200 },
        fill: '#f6c177',
        label: 'Start',
      })
      .node('b', {
        diamond: { w: 100, h: 80 },
        at: { x: 600, y: 200 },
        fill: '#cba6f7',
        label: 'Decision',
      })
      .node('c', {
        cylinder: { w: 80, h: 100 },
        at: { x: 200, y: 400 },
        fill: '#9ccfd8',
        label: 'Data',
      })
      .node('d', {
        star: { points: 5, outerR: 45, innerR: 20 },
        at: { x: 600, y: 400 },
        fill: '#eb6f92',
        label: 'Finish',
      })

      .node('center', {
        hexagon: { r: 50 },
        at: { x: 400, y: 300 },
        fill: '#ebbcba',
        label: 'Hub',
      })

      // Connect them together
      .edge('a', 'center', { stroke: { color: '#666', width: 2 }, arrow: true })
      .edge('center', 'b', { stroke: { color: '#666', width: 2 }, arrow: true })
      .edge('center', 'c', {
        stroke: { color: '#666', width: 2 },
        arrow: true,
        dash: 'dashed',
      })
      .edge('c', 'd', {
        stroke: { color: '#666', width: 2 },
        arrow: true,
        routing: 'orthogonal',
      })
      .edge('b', 'd', { stroke: { color: '#666', width: 2 }, arrow: true })

      // Extra nodes way off to show we can zoom out
      .node('far', {
        cloud: { w: 100, h: 60 },
        at: { x: 1000, y: -100 },
        fill: '#31748f',
        label: 'Cloud',
      })
      .edge('b', 'far', {
        stroke: { color: '#666', width: 2 },
        arrow: true,
        dash: 'dotted',
      })}
  />
</CodePreview>

```ts
import { viz } from 'vizcraft';

const scene = viz()
  .view(800, 600)
  .node('a', { circle: { r: 40 }, at: { x: 200, y: 200 }, fill: '#f6c177' })
  .node('b', {
    diamond: { w: 100, h: 80 },
    at: { x: 600, y: 200 },
    fill: '#cba6f7',
  })
  .edge('a', 'b', { arrow: true });

// Enable interactive panning and zooming
const controller = scene.mount(document.getElementById('viz'), {
  panZoom: true,
  minZoom: 0.1, // default
  maxZoom: 5, // default
  initialZoom: 'fit', // default
});
```

## Programmatic Control

When you mount a scene with `panZoom: true`, an initialized `PanZoomController` is returned. You can use this controller to implement external minimatrix navigation, target specific graph nodes, or reset views programmatically.

```ts
// Fit all elements neatly in the view
controller.fitToContent((padding = 20));

// Zoom and center directly onto a specific node ID
controller.zoomToNode('user-node');

// Manually assign offset and scale factors
controller.setZoom(2.5); // 250% zoom
controller.setPan({ x: -100, y: -50 });

// Reset the view to its initial zoom specifications
controller.reset();

// Subscribe to viewport modifications
const unsubscribe = controller.onChange(({ zoom, pan }) => {
  console.log('Scale:', zoom, 'Translation:', pan);
});
```
