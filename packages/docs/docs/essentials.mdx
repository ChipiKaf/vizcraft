---
sidebar_position: 2
title: Essentials
---

import CodePreview from '@site/src/components/CodePreview';
import VizMount from '@site/src/components/VizMount';
import { viz, circularLayout, gridLayout } from 'vizcraft';

export const circularLayoutBuilder = viz()
  .view(500, 300)
  .node('a').circle(30).fill('#89b4fa')
  .node('b').circle(30).fill('#a6e3a1')
  .node('c').circle(30).fill('#f9e2af')
  .node('d').circle(30).fill('#f38ba8')
  .edge('a', 'b')
  .edge('b', 'c')
  .edge('c', 'd')
  .edge('d', 'a')
  .done()
  .layout(circularLayout, { cx: 250, cy: 150, radius: 80 });

export const gridLayoutBuilder = viz()
  .view(500, 300)
  .node('1').rect(40, 40).fill('#cba6f7')
  .node('2').rect(40, 40).fill('#89b4fa')
  .node('3').rect(40, 40).fill('#a6e3a1')
  .node('4').rect(40, 40).fill('#f9e2af')
  .node('5').rect(40, 40).fill('#fab387')
  .node('6').rect(40, 40).fill('#f38ba8')
  .done()
  .layout(gridLayout, { cols: 3, x: 100, y: 70, colSpacing: 150, rowSpacing: 160 })
  .edge('1', '2').routing('orthogonal')
  .edge('2', '3').routing('orthogonal')
  .edge('4', '5').routing('orthogonal')
  .edge('5', '6').routing('orthogonal')
  .done();

export const gridBuilder = viz().view(500, 300);
export const gridScene = gridBuilder
  .grid(5, 3, { x: 20, y: 20 })
  .node('n1')
  .cell(0, 0)
  .label('0,0')
  .rect(60, 40)
  .node('n2')
  .cell(2, 1)
  .label('2,1')
  .circle(30)
  .node('n3')
  .cell(4, 2)
  .label('4,2')
  .diamond(60, 60)
  .done();

export const declarativeScene = viz()
  .view(500, 250)
  .node('start', {
    circle: { r: 22 },
    at: { x: 80, y: 125 },
    fill: '#4CAF50',
    label: 'Start',
  })
  .node('process', {
    rect: { w: 110, h: 50 },
    at: { x: 250, y: 125 },
    fill: '#2196F3',
    stroke: { color: '#1565C0', width: 2 },
    label: { text: 'Process', fontSize: 13, fill: 'white' },
  })
  .node('end', {
    diamond: { w: 70, h: 50 },
    at: { x: 420, y: 125 },
    fill: '#FF9800',
    label: 'End?',
  })
  .edge('start', 'process', { arrow: true, stroke: '#666' })
  .edge('process', 'end', { arrow: true, dash: 'dashed', label: 'next' });

export const edgesBuilder = viz().view(500, 200);
export const edgesScene = edgesBuilder
  .node('A')
  .at(50, 100)
  .circle(26)
  .label('Start')
  .node('B')
  .at(450, 100)
  .rect(80, 40)
  .label('End')
  .edge('A', 'B')
  .arrow()
  .label('Connects to')
  .done();

export const shapesScene = viz()
  .view(700, 960)
  .node('circ')
  .at(60, 80)
  .circle(30)
  .fill('#89b4fa')
  .label('circle')
  .node('rec')
  .at(180, 80)
  .rect(80, 50, 8)
  .fill('#a6e3a1')
  .label('rect')
  .node('dia')
  .at(310, 80)
  .diamond(70, 70)
  .fill('#f9e2af')
  .label('diamond')
  .node('cyl')
  .at(450, 80)
  .cylinder(80, 60)
  .fill('#fab387')
  .label('cylinder')
  .node('hex')
  .at(100, 210)
  .hexagon(40)
  .fill('#cba6f7')
  .label('hexagon')
  .node('hexf')
  .at(240, 210)
  .hexagon(40, 'flat')
  .fill('#f5c2e7')
  .label('hex (flat)')
  .node('ell')
  .at(410, 210)
  .ellipse(65, 35)
  .fill('#89dceb')
  .label('ellipse')
  .node('pie')
  .at(140, 330)
  .arc(40, 180, 360)
  .fill('#f38ba8')
  .label('arc (half)', { dy: 50 })
  .node('quarter')
  .at(320, 330)
  .arc(40, 0, 90)
  .fill('#fab387')
  .label('arc (quarter)', { dy: 50 })
  .node('open')
  .at(510, 330)
  .arc(40, 45, 315, false)
  .fill('none')
  .stroke('#a6e3a1', 3)
  .label('arc (open)', { dy: 50 })
  .node('ba')
  .at(590, 210)
  .blockArrow(90, 20, 40, 25)
  .fill('#94e2d5')
  .label('block arrow')
  .node('co')
  .at(140, 460)
  .callout(120, 60, { rx: 8 })
  .fill('#f9e2af')
  .label('callout')
  .node('coL')
  .at(350, 460)
  .callout(120, 60, { rx: 8, pointerSide: 'left' })
  .fill('#cba6f7')
  .label('callout (left)')
  .node('cld')
  .at(560, 460)
  .cloud(120, 70)
  .fill('#b4befe')
  .stroke('#585b70', 2)
  .label('cloud')
  .node('crs')
  .at(140, 570)
  .cross(50, 18)
  .fill('#a6e3a1')
  .label('cross')
  .node('cub')
  .at(350, 570)
  .cube(80, 60, 20)
  .fill('#89b4fa')
  .label('cube')
  .node('doc')
  .at(560, 570)
  .document(100, 70)
  .fill('#f9e2af')
  .label('document')
  .node('nt')
  .at(350, 680)
  .note(110, 70)
  .fill('#94e2d5')
  .label('note')
  .node('pth')
  .at(560, 680)
  .path('M 50,0 L 100,38 L 81,100 L 19,100 L 0,38 Z', 100, 100)
  .fill('#f5c2e7')
  .label('path\n(pentagon)')
  .node('par')
  .at(140, 790)
  .parallelogram(120, 55)
  .fill('#cba6f7')
  .label('parallelogram')
  .node('str')
  .at(350, 790)
  .star(5, 40)
  .fill('#f9e2af')
  .label('star')
  .node('trp')
  .at(560, 790)
  .trapezoid(80, 120, 55)
  .fill('#fab387')
  .label('trapezoid')
  .node('tri')
  .at(140, 900)
  .triangle(80, 70)
  .fill('#f38ba8')
  .label('triangle', { dy: 15 })
  .done();

Learn the basics of creating scenes with VizCraft.

## The Builder API

VizCraft uses a fluent builder pattern to construct your scene. The entry point is the \`viz()\` function.

```typescript
import { viz } from 'vizcraft';

const builder = viz().view(800, 600); // Set viewBox
builder.node('a').at(100, 100).circle(24).done(); // Add a node
const scene = builder.build(); // Finalize scene
```

### View & Grid

You can define the canvas size with \`.view(w, h)\` and optionally set up a grid for easy positioning.

<CodePreview code={`
import { viz } from 'vizcraft';

const builder = viz().view(500, 300);

builder
.grid(5, 3, { x: 20, y: 20 }) // 5 cols, 3 rows, 20px padding
.node('n1').cell(0, 0).label('0,0').rect(60, 40)
.node('n2').cell(2, 1).label('2,1').circle(30)
.node('n3').cell(4, 2).label('4,2').diamond(60, 60).done();

const container = document.getElementById('viz-grid');
if (container) builder.mount(container);
`}>

  <VizMount
    builder={gridScene}
    style={{ height: '300px', width: '100%', border: '1px solid #ccc' }}
  />
</CodePreview>

### Mounting and Destroying

Once a scene is built, you render it to the DOM by passing an `HTMLElement` to `builder.mount()`. This injects the SVG and sets up any requested controllers (like pan/zoom).

When you are done with a visualization — for example, when navigating away from a page or switching diagrams — you should call `builder.destroy()`. 

```typescript
// Render the scene
builder.mount(containerElement);

// Later, when cleaning up:
builder.destroy();
```

Calling `destroy()` removes the SVG from the DOM, destroys the pan/zoom controller, cancels animation loops, and cleans up internal event listeners.

## Declarative Options Overloads

Instead of chaining many fluent methods, you can also pass an **options object** as the second argument to `.node()` or the third argument to `.edge()`. This configures the element in a single call and returns the `VizBuilder` so you can continue adding more elements.

```typescript
// Fluent style
viz()
  .node('a')
  .at(100, 100)
  .rect(80, 40)
  .fill('steelblue')
  .label('A')
  .edge('a', 'b')
  .arrow()
  .stroke('red')
  .build();

// Declarative style — same result
viz()
  .node('a', {
    at: { x: 100, y: 100 },
    rect: { w: 80, h: 40 },
    fill: 'steelblue',
    label: 'A',
  })
  .edge('a', 'b', { arrow: true, stroke: 'red' })
  .build();
```

:::tip
**When to use which?** Use declarative options when you know all the properties up-front (e.g. from data). Use fluent chaining when you want to add properties conditionally or need the intermediate `NodeBuilder` / `EdgeBuilder`.
:::

### `node(id, opts: NodeOptions)`

Returns **`VizBuilder`** (not `NodeBuilder`), so you can chain the next element immediately.

| Option                         | Type                                | Maps to                           |
| ------------------------------ | ----------------------------------- | --------------------------------- |
| `at`                           | `{ x, y }`                          | `.at(x, y)`                       |
| `cell`                         | `{ col, row, align? }`              | `.cell(col, row, align)`          |
| `circle`, `rect`, `diamond`, … | shape params                        | `.circle(r)`, `.rect(w, h)`, etc. |
| `fill`                         | `string`                            | `.fill(color)`                    |
| `stroke`                       | `string \| { color, width? }`       | `.stroke(color, width)`           |
| `opacity`                      | `number`                            | `.opacity(n)`                     |
| `zIndex`                       | `number`                            | `.zIndex(value)`                  |
| `className`                    | `string`                            | `.class(name)`                    |
| `label`                        | `string \| { text, …labelOpts }`    | `.label(text, opts)`              |
| `image`                        | `{ href, width, height, …opts }`    | `.image(href, w, h, opts)`        |
| `ports`                        | `Array<{ id, offset, direction? }>` | `.port(id, offset, dir)`          |
| `container`                    | `ContainerConfig`                   | `.container(config)`              |
| `parent`                       | `string`                            | `.parent(id)`                     |
| `data`                         | `unknown`                           | `.data(value)`                    |
| `onClick`                      | `(id, node) => void`                | `.onClick(fn)`                    |

### `edge(from, to, opts: EdgeOptions)`

Returns **`VizBuilder`** (not `EdgeBuilder`).

| Option                      | Type                                           | Maps to                                   |
| --------------------------- | ---------------------------------------------- | ----------------------------------------- |
| `id`                        | `string`                                       | custom edge id                            |
| `routing`                   | `EdgeRouting`                                  | `.routing(type)`                          |
| `waypoints`                 | `Vec2[]`                                       | `.via(x, y)` per waypoint                 |
| `arrow`                     | `boolean \| 'both' \| 'start' \| 'end'`        | `.arrow(value)`                           |
| `markerStart` / `markerEnd` | `EdgeMarkerType`                               | `.markerStart(type)` / `.markerEnd(type)` |
| `stroke`                    | `string \| { color, width? }`                  | `.stroke(color, width)`                   |
| `fill`                      | `string`                                       | `.fill(color)`                            |
| `opacity`                   | `number`                                       | `.opacity(n)`                             |
| `dash`                      | `'dashed' \| 'dotted' \| 'dash-dot' \| string` | `.dash(value)`                            |
| `className`                 | `string`                                       | `.class(name)`                            |
| `anchor`                    | `'center' \| 'boundary'`                       | `.connect(anchor)`                        |
| `fromPort` / `toPort`       | `string`                                       | `.fromPort(id)` / `.toPort(id)`           |
| `label`                     | `string \| labelObj \| labelObj[]`             | `.label(text, opts)`                      |
| `hitArea`                   | `number`                                       | `.hitArea(width)`                         |
| `data`                      | `unknown`                                      | `.data(value)`                            |
| `onClick`                   | `(id, edge) => void`                           | `.onClick(fn)`                            |

### Live example

<CodePreview code={`
import { viz } from 'vizcraft';

const builder = viz()
.view(500, 250)
.node('start', {
circle: { r: 22 },
at: { x: 80, y: 125 },
fill: '#4CAF50',
label: 'Start',
})
.node('process', {
rect: { w: 110, h: 50 },
at: { x: 250, y: 125 },
fill: '#2196F3',
stroke: { color: '#1565C0', width: 2 },
label: { text: 'Process', fontSize: 13, fill: 'white' },
})
.node('end', {
diamond: { w: 70, h: 50 },
at: { x: 420, y: 125 },
fill: '#FF9800',
label: 'End?',
})
.edge('start', 'process', { arrow: true, stroke: '#666' })
.edge('process', 'end', { arrow: true, dash: 'dashed', label: 'next' });

const el = document.getElementById('viz-container');
if (el) builder.mount(el);
`}>

  <VizMount builder={declarativeScene} style={{ height: '250px', width: '100%' }} />
</CodePreview>

You can freely mix both styles in the same graph — use declarative calls for data-driven elements and fluent chaining when you need conditional logic.

### Re-opening a declarative node or edge

Because `node(id, opts)` returns `VizBuilder`, you no longer have the `NodeBuilder` for further chaining. If you need to go back and add more properties later, just call `.node(id)` again **without** options — this re-opens the same node and returns its `NodeBuilder`:

```typescript
viz()
  .node('a', { rect: { w: 80, h: 40 }, fill: 'blue', at: { x: 100, y: 100 } })
  // ... other nodes / edges ...
  .node('a') // re-opens 'a' → returns NodeBuilder
  .label('Hello') // continue editing the same node
  .stroke('red')
  .build();
```

The same applies to edges — calling `.edge(from, to)` or `.edge(from, to, id)` for an existing edge id will return its `EdgeBuilder` so you can keep editing it.

:::info
This works because the builder stores nodes and edges by id internally. A second call with the same id reuses the existing definition rather than creating a new one. All properties — whether set declaratively or via chaining — accumulate on the same object.
:::

## Auto-Layout

Instead of manually positioning nodes with `.at(x, y)` or `.cell(col, row)`, you can use **Auto-Layout Algorithms**. VizCraft comes with a few basic algorithms (`circularLayout`, `gridLayout`) built-in, and the architecture is pluggable so you can bring your own algorithm (like Dagre).

Simply define your nodes and edges, then call `builder.layout()` before building the scene.

<CodePreview code={`
import { viz, circularLayout } from 'vizcraft';

const builder = viz().view(500, 300);

builder.node('a').circle(30).fill('#89b4fa');
builder.node('b').circle(30).fill('#a6e3a1');
builder.node('c').circle(30).fill('#f9e2af');
builder.node('d').circle(30).fill('#f38ba8');

builder.edge('a', 'b');
builder.edge('b', 'c');
builder.edge('c', 'd');
builder.edge('d', 'a');

// Automatically arrange the nodes in a circle
builder.layout(circularLayout, {
  cx: 250,
  cy: 150,
  radius: 80
});

const container = document.getElementById('viz-layout-circle');
if (container) builder.mount(container);
`}>

  <VizMount
    builder={circularLayoutBuilder}
    style={{ height: '300px', width: '100%', border: '1px solid #ccc' }}
  />
</CodePreview>

You can also use the `gridLayout` algorithm to arrange nodes into rows and columns:

<CodePreview code={`
import { viz, gridLayout } from 'vizcraft';

const builder = viz().view(500, 300);

builder.node('1').rect(40, 40).fill('#cba6f7');
builder.node('2').rect(40, 40).fill('#89b4fa');
builder.node('3').rect(40, 40).fill('#a6e3a1');
builder.node('4').rect(40, 40).fill('#f9e2af');
builder.node('5').rect(40, 40).fill('#fab387');
builder.node('6').rect(40, 40).fill('#f38ba8');

// The layout algorithm automatically wraps into columns/rows
builder.layout(gridLayout, {
  cols: 3,
  x: 100,
  y: 70,
  colSpacing: 150,
  rowSpacing: 160
});

// Since the algorithms only position the nodes, we can still chain fluent options:
builder.edge('1', '2').routing('orthogonal');
builder.edge('2', '3').routing('orthogonal');
builder.edge('4', '5').routing('orthogonal');
builder.edge('5', '6').routing('orthogonal');

const container = document.getElementById('viz-layout-grid');
if (container) builder.mount(container);
`}>

  <VizMount
    builder={gridLayoutBuilder}
    style={{ height: '300px', width: '100%', border: '1px solid #ccc' }}
  />
</CodePreview>

A layout algorithm is a function that takes a \`LayoutGraph\` (the current nodes and edges) and returns a \`LayoutResult\` object mapping node IDs to computed \`{x, y}\` coordinates. If you write your own algorithm, just ensure it conforms to the \`LayoutAlgorithm\` TypeScript signature.

## Nodes

Nodes are the primary entities in your graph. You can create them with \`.node(id)\`.

### Shapes

VizCraft supports eighteen built-in shapes plus a generic custom-path escape hatch:

- `.circle(r)` — circle with radius `r`
- `.rect(w, h, [rx])` — rectangle with optional corner radius
- `.diamond(w, h)` — diamond / rhombus
- `.cylinder(w, h, [arcHeight])` — cylinder (the standard database / data-store symbol). `arcHeight` controls the top ellipse arc height (defaults to ~15 % of `h`)
- `.hexagon(r, [orientation])` — regular hexagon with outer radius `r`. `orientation` is `'pointy'` (default, vertex at top) or `'flat'` (flat edge at top)
- `.ellipse(rx, ry)` — ellipse / oval with independent horizontal and vertical radii
- `.arc(r, startAngle, endAngle, [closed])` — arc / pie slice. Angles in degrees (0 = right, 90 = bottom). Defaults to a closed pie; pass `false` for an open arc
- `.blockArrow(length, bodyWidth, headWidth, headLength, [direction])` — thick directional arrow polygon. `direction` is `'right'` (default), `'left'`, `'up'`, or `'down'`
- `.callout(w, h, [opts])` — speech bubble / callout. A rounded rectangle body with a triangular pointer. Options: `rx` (corner radius), `pointerSide` (`'bottom'` default, `'top'`, `'left'`, `'right'`), `pointerHeight`, `pointerWidth`, `pointerPosition` (0–1, default 0.3)
- `.cloud(w, h)` — cloud / thought bubble. A bumpy outline built from cubic Bézier curves, sized to fit within the `w × h` bounding box. Commonly used for external systems, the internet, or cloud services
- `.cross(size, [barWidth])` — cross / plus sign. A 12-vertex polygon. `barWidth` defaults to ~33 % of `size`
- `.cube(w, h, [depth])` — 3D isometric cube / box. Three polygons (front face, top face, right face) with automatic shading for the 3D effect. `depth` (isometric projection offset) defaults to ~20 % of `w`
- `.document(w, h, [waveHeight])` — document (wavy bottom). The standard flowchart document symbol — a rectangle with a sine-wave-like curved bottom edge. `waveHeight` (the wave amplitude) defaults to ~10 % of `h`
- `.note(w, h, [foldSize])` — note (folded corner). The standard UML note / annotation symbol — a rectangle with a dog-eared top-right corner. The fold triangle is rendered with a slightly darker shade. `foldSize` defaults to `15`
- `.parallelogram(w, h, [skew])` — parallelogram (skewed rectangle). The standard ISO 5807 Input/Output symbol. The top edge is shifted right by `skew` (defaults to ~20 % of `w`)
- `.star(points, outerR, [innerR])` — multi-pointed star. `points` is the number of tips, `outerR` the tip radius, `innerR` the valley radius (defaults to ~40 % of `outerR`). Great for ratings, badges, or decorative markers
- `.trapezoid(topW, bottomW, h)` — trapezoid. A quadrilateral with a shorter top edge (`topW`) and a longer bottom edge (`bottomW`). The standard ISO 5807 Manual Operation symbol. Swap `topW` / `bottomW` for an inverted trapezoid (Manual Input)
- `.triangle(w, h, [direction])` — triangle. A 3-vertex polygon with base `w` and height `h`. `direction` is `'up'` (default), `'down'`, `'left'`, or `'right'` — controls which way the apex points. Useful for warnings, data-flow symbols, and hierarchy diagrams
- `.path(d, w, h)` — **custom SVG path** (escape hatch). Supply any SVG path data string as `d`; `w` and `h` define the bounding box used for anchor computation and label centering. The path is translated so the bounding box center aligns with the node position

<CodePreview code={`
import { viz } from 'vizcraft';

const builder = viz().view(700, 960);

builder
.node('circ').at(60, 80).circle(30).fill('#89b4fa').label('circle')
.node('rec').at(180, 80).rect(80, 50, 8).fill('#a6e3a1').label('rect')
.node('dia').at(310, 80).diamond(70, 70).fill('#f9e2af').label('diamond')
.node('cyl').at(450, 80).cylinder(80, 60).fill('#fab387').label('cylinder')
.node('hex').at(100, 210).hexagon(40).fill('#cba6f7').label('hexagon')
.node('hexf').at(240, 210).hexagon(40, 'flat').fill('#f5c2e7').label('hex (flat)')
.node('ell').at(410, 210).ellipse(65, 35).fill('#89dceb').label('ellipse')
.node('pie').at(140, 330).arc(40, 180, 360).fill('#f38ba8').label('arc (half)', { dy: 50 })
.node('quarter').at(320, 330).arc(40, 0, 90).fill('#fab387').label('arc (quarter)', { dy: 50 })
.node('open').at(510, 330).arc(40, 45, 315, false).fill('none').stroke('#a6e3a1', 3).label('arc (open)', { dy: 50 })
.node('ba').at(590, 210).blockArrow(90, 20, 40, 25).fill('#94e2d5').label('block arrow')
.node('co').at(140, 460).callout(120, 60, { rx: 8 }).fill('#f9e2af').label('callout')
.node('coL').at(350, 460).callout(120, 60, { rx: 8, pointerSide: 'left' }).fill('#cba6f7').label('callout (left)')
.node('cld').at(560, 460).cloud(120, 70).fill('#b4befe').stroke('#585b70', 2).label('cloud')
.node('crs').at(140, 570).cross(50, 18).fill('#a6e3a1').label('cross')
.node('cub').at(350, 570).cube(80, 60, 20).fill('#89b4fa').label('cube')
.node('doc').at(560, 570).document(100, 70).fill('#f9e2af').label('document')
.node('nt').at(350, 680).note(110, 70).fill('#94e2d5').label('note')
.node('pth').at(560, 680).path('M 50,0 L 100,38 L 81,100 L 19,100 L 0,38 Z', 100, 100).fill('#f5c2e7').label('path (pentagon)', { maxWidth: 80 })
.node('par').at(140, 790).parallelogram(120, 55).fill('#cba6f7').label('parallelogram')
.node('str').at(350, 790).star(5, 40).fill('#f9e2af').label('star')
.node('trp').at(560, 790).trapezoid(80, 120, 55).fill('#fab387').label('trapezoid')
.node('tri').at(140, 900).triangle(80, 70).fill('#f38ba8').label('triangle', { dy: 15 })
.done();

const container = document.getElementById('viz-shapes');
if (container) builder.mount(container);
`}>

  <VizMount
    builder={shapesScene}
    style={{ height: '920px', width: '100%', border: '1px solid #ccc' }}
  />
</CodePreview>

### Embedded Images

You can embed images or SVG icons directly inside nodes using `.image()`. You can specify dimensions, positioning offsets, and how the image should relate to the node's text label (`above`, `below`, `left`, `right`, or `replace`).

export const imageNodeScene = viz()
  .view(600, 150)
  .node('n1')
  .at(100, 75)
  .circle(40)
  .image('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>', 24, 24, { position: 'above' })
  .label('Info')
  .node('n2')
  .at(300, 75)
  .rect(120, 50, 8)
  .image('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 12h-4l-3 9L9 3l-3 9H2"></path></svg>', 24, 24, { position: 'left' })
  .label('Activity')
  .node('n3')
  .at(500, 75)
  .diamond(80, 80)
  .image('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2v20M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path></svg>', 30, 30, { position: 'replace' })
  .label('Hidden')
  .done();

<CodePreview code={`
import { viz } from 'vizcraft';

const builder = viz().view(600, 150);

builder
  // Image above label
  .node('n1').at(100, 75).circle(40)
  .image('/info-icon.svg', 24, 24, { position: 'above' })
  .label('Info')

  // Image to the left of label
  .node('n2').at(300, 75).rect(120, 50, 8)
  .image('/activity-icon.svg', 24, 24, { position: 'left' })
  .label('Activity')

  // Image replacing label
  .node('n3').at(500, 75).diamond(80, 80)
  .image('/dollar-icon.svg', 30, 30, { position: 'replace' })
  .label('Hidden')
  .done();

const container = document.getElementById('viz-images');
if (container) builder.mount(container);
`}>
  <VizMount
    builder={imageNodeScene}
    style={{ height: '150px', width: '100%', border: '1px solid var(--ifm-color-emphasis-200)' }}
  />
</CodePreview>

### Positioning

- \`.at(x, y)\`: Absolute positioning.
- \`.cell(col, row, [align])\` Grid-based positioning (requires \`.grid()\`).

## Edges

Edges connect two nodes using \`.edge(fromId, toId)\`.
By default, edges stop at the node boundary. Use \`.connect('center')\` to draw center-to-center.

<CodePreview code={`
import { viz } from 'vizcraft';

const builder = viz().view(500, 200);

builder
.node('A')
.at(50, 100)
.circle(26)
.label('Start')
.node('B')
.at(450, 100)
.rect(80, 40)
.label('End')
.edge('A', 'B')
.arrow()
.label('Connects to')
.done();

const container = document.getElementById('viz-edges');
if (container) builder.mount(container);
`}>

  <VizMount builder={edgesScene} style={{ height: '200px', width: '100%' }} />
</CodePreview>

export const multiLineLabelScene = viz()
  .view(600, 260)
  .node('n1')
  .at(100, 60)
  .rect(140, 80)
  .label('Manual\nLine\nBreaks', { lineHeight: 1.4, fontSize: 13, fontWeight: 'bold' })
  .node('n2')
  .at(300, 60)
  .circle(50)
  .label('This long text automatically wraps to fit the shape', { maxWidth: 80, fontSize: 11 })
  .node('n3')
  .at(500, 60)
  .diamond(80, 80)
  .label('Top Align\nText', { verticalAlign: 'top', dy: -20, fontSize: 12 })
  .edge('n1', 'n2')
  .label('Edge\nWrap', { maxWidth: 40, fontSize: 10, fill: '#666' })
  .arrow()
  .edge('n2', 'n3')
  .label('Long edge description\nwrapped\ninto three lines', { maxWidth: 80, fontSize: 10 })
  .arrow()
  .done();

### Multi-Line Labels

By default, SVG `<text>` elements do not support automatic wrapping or newline characters. VizCraft handles this for you automatically when you use `.label()`.

You can break lines manually using the `\n` character, or you can let VizCraft automatically wrap words for you by specifying a `maxWidth` in the label options object. It does this by creating perfectly aligned `<tspan>` sub-elements.

<CodePreview code={`
import { viz } from 'vizcraft';

const builder = viz().view(600, 160);

builder
  // 1. Manual \n breaks
  .node('n1').at(100, 60).rect(140, 80)
  .label('Manual\\nLine\\nBreaks', { lineHeight: 1.4, fontSize: 13, fontWeight: 'bold' })

  // 2. Auto word-wrap via maxWidth
  .node('n2').at(300, 60).circle(50)
  .label('This long text automatically wraps to fit the shape', { maxWidth: 80, fontSize: 11 })

  // 3. Vertical Alignment
  .node('n3').at(500, 60).diamond(80, 80)
  .label('Top Align\\nText', { verticalAlign: 'top', dy: -20, fontSize: 12 })

  // Edge labels also support wrapping
  .edge('n1', 'n2').arrow()
  .label('Edge\\nWrap', { maxWidth: 40, fontSize: 10, fill: '#666' })
  
  .edge('n2', 'n3').arrow()
  .label('Long edge description\\nwrapped\\ninto three lines', { maxWidth: 80, fontSize: 10 })
  .done();

const el = document.getElementById('viz-multiline-labels');
if (el) builder.mount(el);
`}>

  <VizMount builder={multiLineLabelScene} style={{ height: '160px', width: '100%' }} />
</CodePreview>

| Label Option      | Type                                       | Effect                                                                               |
| ----------------- | ------------------------------------------ | ------------------------------------------------------------------------------------ |
| `maxWidth`        | \`number\`                                 | Triggers automatic word wrapping when the approximate text width exceeds this value. |
| `lineHeight`      | \`number\`                                 | Vertical spacing multiplier between lines (default: \`1.2\`).                        |
| `verticalAlign`   | \`'top' \| 'middle' \| 'bottom'\`          | Aligns the text block vertically relative to the node's center (default \`'middle'\`). |
| `overflow`        | \`'visible' \| 'ellipsis' \| 'clip'\`      | Defines how to handle text that exceeds bounds after wrapping (basic support).       |

### Edge Routing

Edges support three routing modes: **straight** (default), **curved** (smooth bezier), and **orthogonal** (right-angle elbows).
All edges are rendered as `<path>` elements. Use `.curved()`, `.orthogonal()`, or `.routing(mode)` to set the mode,
and `.via(x, y)` to add intermediate waypoints.

export const edgeRoutingScene = viz()
  .view(600, 260)
  .node('a1')
  .at(50, 60)
  .circle(22)
  .label('A')
  .node('b1')
  .at(250, 60)
  .circle(22)
  .label('B')
  .edge('a1', 'b1')
  .arrow()
  .label('straight')
  .node('a2')
  .at(50, 140)
  .circle(22)
  .label('C')
  .node('b2')
  .at(250, 140)
  .circle(22)
  .label('D')
  .edge('a2', 'b2')
  .curved()
  .arrow()
  .label('curved')
  .node('a3')
  .at(50, 220)
  .circle(22)
  .label('E')
  .node('b3')
  .at(250, 220)
  .circle(22)
  .label('F')
  .edge('a3', 'b3')
  .orthogonal()
  .arrow()
  .label('orthogonal')
  .node('c1')
  .at(370, 60)
  .circle(22)
  .label('G')
  .node('d1')
  .at(560, 220)
  .circle(22)
  .label('H')
  .edge('c1', 'd1')
  .curved()
  .via(460, 60)
  .arrow()
  .label('waypoint')
  .done();

<CodePreview code={`
import { viz } from 'vizcraft';

const builder = viz().view(600, 260);

builder
.node('a1').at(50, 60).circle(22).label('A')
.node('b1').at(250, 60).circle(22).label('B')
.edge('a1', 'b1').arrow().label('straight')
// Curved edge
.node('a2').at(50, 140).circle(22).label('C')
.node('b2').at(250, 140).circle(22).label('D')
.edge('a2', 'b2').curved().arrow().label('curved')
// Orthogonal edge
.node('a3').at(50, 220).circle(22).label('E')
.node('b3').at(250, 220).circle(22).label('F')
.edge('a3', 'b3').orthogonal().arrow().label('orthogonal')
// Curved with waypoint
.node('c1').at(370, 60).circle(22).label('G')
.node('d1').at(560, 220).circle(22).label('H')
.edge('c1', 'd1').curved().via(460, 60).arrow().label('waypoint')
.done();

const el = document.getElementById('viz-edge-routing');
if (el) builder.mount(el);
`}>

  <VizMount builder={edgeRoutingScene} style={{ height: '260px', width: '100%' }} />
</CodePreview>

| Builder method   | Effect                                                                               |
| ---------------- | ------------------------------------------------------------------------------------ |
| `.straight()`    | Straight line routing (default).                                                     |
| `.curved()`      | Smooth bezier curve.                                                                 |
| `.orthogonal()`  | Right-angle (elbow) connectors.                                                      |
| `.routing(mode)` | Set routing mode programmatically (`'straight'`, `'curved'`, or `'orthogonal'`).     |
| `.via(x, y)`     | Add an intermediate waypoint. Chain multiple `.via()` calls for multi-segment paths. |

### Edge Labels

Use `.label(text)` to add a text label at the midpoint of an edge. Chain multiple `.label()` calls with a `position` option to place labels at **start**, **mid**, or **end** — useful for ER-diagram cardinalities, protocol annotations, or any edge that needs more than one label.

| Position  | Placement                       |
| --------- | ------------------------------- |
| `'start'` | ~15 % from the source node.     |
| `'mid'`   | Midpoint of the path (default). |
| `'end'`   | ~85 % toward the target node.   |

export const edgeLabelScene = viz()
  .view(600, 220)
  .node('users')
  .at(80, 110)
  .rect(100, 50)
  .label('Users')
  .node('orders')
  .at(340, 60)
  .rect(100, 50)
  .label('Orders')
  .node('products')
  .at(340, 170)
  .rect(100, 50)
  .label('Products')
  .edge('users', 'orders')
  .label('1', { position: 'start' })
  .label('places', { position: 'mid' })
  .label('*', { position: 'end' })
  .arrow()
  .edge('orders', 'products')
  .curved()
  .label('*', { position: 'start' })
  .label('contains', { position: 'mid' })
  .label('*', { position: 'end' })
  .arrow()
  .done();

<CodePreview code={`
import { viz } from 'vizcraft';

const builder = viz().view(600, 220);

builder
.node('users').at(80, 110).rect(100, 50).label('Users')
.node('orders').at(340, 60).rect(100, 50).label('Orders')
.node('products').at(340, 170).rect(100, 50).label('Products')
// ER-style: 1 user places _ orders
.edge('users', 'orders')
.label('1', { position: 'start' })
.label('places', { position: 'mid' })
.label('_', { position: 'end' })
.arrow()
// _ orders contain _ products (curved)
.edge('orders', 'products')
.curved()
.label('_', { position: 'start' })
.label('contains', { position: 'mid' })
.label('_', { position: 'end' })
.arrow()
.done();

const el = document.getElementById('viz-edge-labels');
if (el) builder.mount(el);
`}>

  <VizMount builder={edgeLabelScene} style={{ height: '220px', width: '100%' }} />
</CodePreview>

| Builder method        | Effect                                                                                                                                      |
| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |
| `.label(text)`        | Add a label at the midpoint (default position `'mid'`).                                                                                     |
| `.label(text, opts?)` | Add a label with options. `opts.position` can be `'start'`, `'mid'`, or `'end'`. `opts.className`, `opts.dx`, `opts.dy` are also available. |

:::tip
You can chain `.label()` as many times as you like — each call adds an additional label. The `dy` default of `-10` places text slightly above the path.
:::

### Edge Styling

Like nodes, edges can be styled **per-edge** via the builder using `.stroke()`, `.fill()`, `.opacity()`, `.dashed()`, `.dotted()`, and `.dash()`.
When set, these produce inline SVG attributes that override the CSS defaults (`.viz-edge { fill: none; stroke: currentColor }`).
If no style is set, the CSS class defaults apply — so you can still theme everything via CSS.

export const edgeStyleScene = viz()
  .view(600, 220)
  .node('a1')
  .at(50, 60)
  .circle(22)
  .label('A')
  .node('b1')
  .at(250, 60)
  .circle(22)
  .label('B')
  .edge('a1', 'b1')
  .stroke('#e74c3c', 3)
  .arrow()
  .label('red 3px')
  .node('a2')
  .at(50, 140)
  .circle(22)
  .label('C')
  .node('b2')
  .at(250, 140)
  .circle(22)
  .label('D')
  .edge('a2', 'b2')
  .stroke('#2ecc71', 2)
  .opacity(0.6)
  .arrow()
  .label('green 60%')
  .node('c1')
  .at(370, 60)
  .circle(22)
  .label('E')
  .node('d1')
  .at(560, 140)
  .circle(22)
  .label('F')
  .edge('c1', 'd1')
  .curved()
  .stroke('#3498db', 4)
  .arrow()
  .label('blue curved')
  .done();

<CodePreview code={`
import { viz } from 'vizcraft';

const builder = viz().view(600, 220);

builder
.node('a1').at(50, 60).circle(22).label('A')
.node('b1').at(250, 60).circle(22).label('B')
.edge('a1', 'b1').stroke('#e74c3c', 3).arrow().label('red 3px')
// Green edge at 60% opacity
.node('a2').at(50, 140).circle(22).label('C')
.node('b2').at(250, 140).circle(22).label('D')
.edge('a2', 'b2').stroke('#2ecc71', 2).opacity(0.6).arrow().label('green 60%')
// Blue curved edge
.node('c1').at(370, 60).circle(22).label('E')
.node('d1').at(560, 140).circle(22).label('F')
.edge('c1', 'd1').curved().stroke('#3498db', 4).arrow().label('blue curved')
.done();

const el = document.getElementById('viz-edge-style');
if (el) builder.mount(el);
`}>

  <VizMount builder={edgeStyleScene} style={{ height: '220px', width: '100%' }} />
</CodePreview>

| Builder method           | Effect                                                                                  |
| ------------------------ | --------------------------------------------------------------------------------------- |
| `.stroke(color, width?)` | Set stroke color and optional width (overrides CSS).                                    |
| `.fill(color)`           | Set fill color (overrides CSS default of `none`).                                       |
| `.opacity(value)`        | Set opacity 0–1 (overrides CSS).                                                        |
| `.dashed()`              | Dashed stroke (`8, 4`).                                                                 |
| `.dotted()`              | Dotted stroke (`2, 4`).                                                                 |
| `.dash(pattern)`         | Custom SVG dasharray, or preset name (`'dashed'`, `'dotted'`, `'dash-dot'`, `'solid'`). |

:::tip
You can combine per-edge styling with CSS classes. Use `.class('my-edge')` for broad theming and `.stroke()` / `.fill()` / `.opacity()` / `.dashed()` for one-off overrides.
:::

#### Dash Patterns

Use `.dashed()`, `.dotted()`, or `.dash(pattern)` to control the line style.
Preset names resolve to standard SVG `stroke-dasharray` values, or pass any custom dasharray string.

| Preset       | `stroke-dasharray` |
| ------------ | ------------------ |
| `'solid'`    | none               |
| `'dashed'`   | `8, 4`             |
| `'dotted'`   | `2, 4`             |
| `'dash-dot'` | `8, 4, 2, 4`       |

export const edgeDashScene = viz()
  .view(600, 240)
  .node('a1')
  .at(50, 40)
  .circle(18)
  .label('A')
  .node('b1')
  .at(250, 40)
  .circle(18)
  .label('B')
  .edge('a1', 'b1')
  .dashed()
  .stroke('#e74c3c')
  .arrow()
  .label('dashed')
  .node('a2')
  .at(50, 120)
  .circle(18)
  .label('C')
  .node('b2')
  .at(250, 120)
  .circle(18)
  .label('D')
  .edge('a2', 'b2')
  .dotted()
  .stroke('#2ecc71')
  .arrow()
  .label('dotted')
  .node('c1')
  .at(350, 40)
  .circle(18)
  .label('E')
  .node('d1')
  .at(560, 40)
  .circle(18)
  .label('F')
  .edge('c1', 'd1')
  .dash('dash-dot')
  .stroke('#3498db')
  .arrow()
  .label('dash-dot')
  .node('c2')
  .at(350, 120)
  .circle(18)
  .label('G')
  .node('d2')
  .at(560, 120)
  .circle(18)
  .label('H')
  .edge('c2', 'd2')
  .dash('12, 3, 3, 3')
  .stroke('#9b59b6')
  .arrow()
  .label('custom')
  .node('a3')
  .at(50, 200)
  .circle(18)
  .label('I')
  .node('b3')
  .at(250, 200)
  .circle(18)
  .label('J')
  .edge('a3', 'b3')
  .stroke('#6c7086')
  .arrow()
  .label('solid (default)')
  .done();

<CodePreview code={`
import { viz } from 'vizcraft';

const builder = viz().view(600, 240);

builder
.node('a1').at(50, 40).circle(18).label('A')
.node('b1').at(250, 40).circle(18).label('B')
.edge('a1', 'b1').dashed().stroke('#e74c3c').arrow().label('dashed')

.node('a2').at(50, 120).circle(18).label('C')
.node('b2').at(250, 120).circle(18).label('D')
.edge('a2', 'b2').dotted().stroke('#2ecc71').arrow().label('dotted')

.node('c1').at(350, 40).circle(18).label('E')
.node('d1').at(560, 40).circle(18).label('F')
.edge('c1', 'd1').dash('dash-dot').stroke('#3498db').arrow().label('dash-dot')

.node('c2').at(350, 120).circle(18).label('G')
.node('d2').at(560, 120).circle(18).label('H')
.edge('c2', 'd2').dash('12, 3, 3, 3').stroke('#9b59b6').arrow().label('custom')

.node('a3').at(50, 200).circle(18).label('I')
.node('b3').at(250, 200).circle(18).label('J')
.edge('a3', 'b3').stroke('#6c7086').arrow().label('solid (default)')
.done();

const el = document.getElementById('viz-edge-dash');
if (el) builder.mount(el);
`}>

  <VizMount builder={edgeDashScene} style={{ height: '240px', width: '100%' }} />
</CodePreview>

### Edge Markers (Arrowheads)

Edges support a rich set of **marker types** — arrowheads, diamonds, circles, bars, and more — at **both ends** of the path.
This makes it easy to express UML, ER, and BPMN relationship semantics.

Use `.markerEnd(type)` and `.markerStart(type)` to set markers explicitly, or `.arrow()` as a shorthand for the common arrow marker.

export const edgeMarkerScene = viz()
  .view(620, 340)
  .node('a1')
  .at(50, 40)
  .circle(18)
  .label('A')
  .node('b1')
  .at(280, 40)
  .circle(18)
  .label('B')
  .edge('a1', 'b1')
  .arrow()
  .label('arrow')
  .node('a2')
  .at(50, 100)
  .circle(18)
  .label('C')
  .node('b2')
  .at(280, 100)
  .circle(18)
  .label('D')
  .edge('a2', 'b2')
  .markerEnd('arrowOpen')
  .label('arrowOpen')
  .node('a3')
  .at(50, 160)
  .circle(18)
  .label('E')
  .node('b3')
  .at(280, 160)
  .circle(18)
  .label('F')
  .edge('a3', 'b3')
  .markerStart('diamond')
  .markerEnd('arrow')
  .label('composition')
  .node('a4')
  .at(340, 40)
  .circle(18)
  .label('G')
  .node('b4')
  .at(570, 40)
  .circle(18)
  .label('H')
  .edge('a4', 'b4')
  .markerStart('diamondOpen')
  .markerEnd('arrow')
  .label('aggregation')
  .node('a5')
  .at(340, 100)
  .circle(18)
  .label('I')
  .node('b5')
  .at(570, 100)
  .circle(18)
  .label('J')
  .edge('a5', 'b5')
  .markerStart('circleOpen')
  .markerEnd('arrow')
  .label('assoc')
  .node('a6')
  .at(340, 160)
  .circle(18)
  .label('K')
  .node('b6')
  .at(570, 160)
  .circle(18)
  .label('L')
  .edge('a6', 'b6')
  .arrow('both')
  .label('bidirectional')
  .node('a7')
  .at(50, 220)
  .circle(18)
  .label('M')
  .node('b7')
  .at(280, 220)
  .circle(18)
  .label('N')
  .edge('a7', 'b7')
  .markerEnd('bar')
  .label('bar (ER)')
  .node('a8')
  .at(340, 220)
  .circle(18)
  .label('O')
  .node('b8')
  .at(570, 220)
  .circle(18)
  .label('P')
  .edge('a8', 'b8')
  .markerEnd('circle')
  .label('circle')
  .node('a9')
  .at(50, 280)
  .circle(18)
  .label('Q')
  .node('b9')
  .at(280, 280)
  .circle(18)
  .label('R')
  .edge('a9', 'b9')
  .markerEnd('square')
  .label('square')
  .node('a10')
  .at(340, 280)
  .circle(18)
  .label('S')
  .node('b10')
  .at(570, 280)
  .circle(18)
  .label('T')
  .edge('a10', 'b10')
  .markerEnd('halfArrow')
  .label('halfArrow')
  .done();

<CodePreview code={`
import { viz } from 'vizcraft';

const builder = viz().view(620, 340);

builder
// Basic arrow
.node('a1').at(50, 40).circle(18).label('A')
.node('b1').at(280, 40).circle(18).label('B')
.edge('a1', 'b1').arrow().label('arrow')
// Open arrow (inheritance)
.node('a2').at(50, 100).circle(18).label('C')
.node('b2').at(280, 100).circle(18).label('D')
.edge('a2', 'b2').markerEnd('arrowOpen').label('arrowOpen')
// UML composition: diamond start + arrow end
.node('a3').at(50, 160).circle(18).label('E')
.node('b3').at(280, 160).circle(18).label('F')
.edge('a3', 'b3').markerStart('diamond').markerEnd('arrow').label('composition')
// UML aggregation: open diamond start + arrow end
.node('a4').at(340, 40).circle(18).label('G')
.node('b4').at(570, 40).circle(18).label('H')
.edge('a4', 'b4').markerStart('diamondOpen').markerEnd('arrow').label('aggregation')
// Association with circle marker
.node('a5').at(340, 100).circle(18).label('I')
.node('b5').at(570, 100).circle(18).label('J')
.edge('a5', 'b5').markerStart('circleOpen').markerEnd('arrow').label('assoc')
// Bidirectional
.node('a6').at(340, 160).circle(18).label('K')
.node('b6').at(570, 160).circle(18).label('L')
.edge('a6', 'b6').arrow('both').label('bidirectional')
// Bar (ER cardinality)
.node('a7').at(50, 220).circle(18).label('M')
.node('b7').at(280, 220).circle(18).label('N')
.edge('a7', 'b7').markerEnd('bar').label('bar (ER)')
// Other types
.node('a8').at(340, 220).circle(18).label('O')
.node('b8').at(570, 220).circle(18).label('P')
.edge('a8', 'b8').markerEnd('circle').label('circle')
.node('a9').at(50, 280).circle(18).label('Q')
.node('b9').at(280, 280).circle(18).label('R')
.edge('a9', 'b9').markerEnd('square').label('square')
.node('a10').at(340, 280).circle(18).label('S')
.node('b10').at(570, 280).circle(18).label('T')
.edge('a10', 'b10').markerEnd('halfArrow').label('halfArrow')
.done();

const el = document.getElementById('viz-edge-markers');
if (el) builder.mount(el);
`}>

  <VizMount builder={edgeMarkerScene} style={{ height: '340px', width: '100%' }} />
</CodePreview>

| Builder method       | Effect                                                                                |
| -------------------- | ------------------------------------------------------------------------------------- |
| `.arrow()`           | Shorthand: set `markerEnd` to `'arrow'` (default arrowhead).                          |
| `.arrow('both')`     | Bidirectional: set both `markerStart` and `markerEnd` to `'arrow'`.                   |
| `.arrow('start')`    | Set only `markerStart` to `'arrow'`.                                                  |
| `.arrow('end')`      | Set only `markerEnd` to `'arrow'` (same as `.arrow()`).                               |
| `.arrow(false)`      | Remove the default arrow marker (`markerEnd: 'none'`).                                |
| `.markerEnd(type)`   | Set the marker at the **target** end. See [EdgeMarkerType](./types#edge-marker-type). |
| `.markerStart(type)` | Set the marker at the **source** end. See [EdgeMarkerType](./types#edge-marker-type). |

:::tip
Marker colors automatically match the edge's stroke color. If you use `.stroke('#e74c3c')`, the marker will also be red — no extra config needed.
:::

### Connection Ports

By default, edges connect to the nearest point on the node boundary. **Connection ports** let you control exactly _where_ on a node an edge attaches — think database connectors, circuit diagrams, or any scenario requiring precise anchor points.

#### Mental model

- Every shape has **default ports** (e.g. `top`, `right`, `bottom`, `left` for rectangles) — you can use them without any extra configuration.
- You can define **explicit ports** with `.port(id, offset, direction?)` on the builder. Explicit ports replace the defaults entirely.
- On edges, use `.fromPort(id)` / `.toPort(id)` to target a specific port. If the port isn't found, the edge falls back to the normal boundary intersection.

export const portScene = viz()
  .view(600, 300)
  .node('server')
  .at(120, 150)
  .rect(100, 80, 8)
  .label('Server')
  .fill('#DBEAFE')
  .stroke('#1D4ED8', 2)
  .port('out-1', { x: 50, y: -20 })
  .port('out-2', { x: 50, y: 20 })
  .node('db')
  .at(450, 80)
  .cylinder(90, 60)
  .label('DB')
  .fill('#DCFCE7')
  .stroke('#166534', 2)
  .port('in', { x: -45, y: 0 })
  .node('cache')
  .at(450, 230)
  .rect(90, 50, 8)
  .label('Cache')
  .fill('#FEF3C7')
  .stroke('#92400E', 2)
  .port('in', { x: -45, y: 0 })
  .edge('server', 'db')
  .fromPort('out-1')
  .toPort('in')
  .arrow()
  .label('queries')
  .edge('server', 'cache')
  .fromPort('out-2')
  .toPort('in')
  .arrow()
  .label('reads')
  .done();

<CodePreview code={`
import { viz } from 'vizcraft';

const builder = viz().view(600, 300);

builder
// Server with two output ports on the right side
.node('server').at(120, 150).rect(100, 80, 8)
.label('Server').fill('#DBEAFE').stroke('#1D4ED8', 2)
.port('out-1', { x: 50, y: -20 })
.port('out-2', { x: 50, y: 20 })
// Database with an input port on the left
.node('db').at(450, 80).cylinder(90, 60)
.label('DB').fill('#DCFCE7').stroke('#166534', 2)
.port('in', { x: -45, y: 0 })
// Cache with an input port on the left
.node('cache').at(450, 230).rect(90, 50, 8)
.label('Cache').fill('#FEF3C7').stroke('#92400E', 2)
.port('in', { x: -45, y: 0 })
// Edges target specific ports
.edge('server', 'db').fromPort('out-1').toPort('in').arrow().label('queries')
.edge('server', 'cache').fromPort('out-2').toPort('in').arrow().label('reads')
.done();

const el = document.getElementById('viz-ports');
if (el) builder.mount(el);
`}>

  <VizMount builder={portScene} style={{ height: '300px', width: '100%' }} />
</CodePreview>

#### Using default ports (no `.port()` needed)

Every shape comes with default ports you can reference by name — no explicit port definitions required:

```typescript
// Rectangle default ports: 'top', 'right', 'bottom', 'left'
builder
  .node('A')
  .at(100, 100)
  .rect(80, 50)
  .node('B')
  .at(300, 100)
  .rect(80, 50)
  .edge('A', 'B')
  .fromPort('right') // right side of A
  .toPort('left') // left side of B
  .arrow();
```

#### Builder API reference

| Builder method (Node)          | Effect                                                                                                |
| ------------------------------ | ----------------------------------------------------------------------------------------------------- |
| `.port(id, offset)`            | Add a named port at `offset` (`{ x, y }`) relative to the node center.                                |
| `.port(id, offset, direction)` | Same, with an outgoing `direction` in degrees (0 = right, 90 = down). Used for tangent-aware routing. |

| Builder method (Edge) | Effect                                                                                |
| --------------------- | ------------------------------------------------------------------------------------- |
| `.fromPort(portId)`   | Connect from a specific port on the source node. Falls back to boundary if not found. |
| `.toPort(portId)`     | Connect to a specific port on the target node. Falls back to boundary if not found.   |

#### Rendering

When a node has **explicit** ports (set via `.port()`), small circles are rendered at each port position. These are hidden by default and appear on hover — useful for visual debugging and interactive editors.

| CSS class                         | Description                                     |
| --------------------------------- | ----------------------------------------------- |
| `.viz-port`                       | The port circle element (opacity 0 by default). |
| `.viz-node-group:hover .viz-port` | Ports become visible on hover (opacity 1).      |

Port elements carry `data-node` and `data-port` attributes for easy DOM querying.

:::tip
For the full type reference (including default ports per shape and utility functions), see [NodePort](./types#nodeport).
:::

## Animations

For a full breakdown (registry/CSS animations, data-only timelines, playback controls, and live examples), see the dedicated guide:

- [Animations](./animations)

---

## Container / Group Nodes

Container nodes let you group children visually — think swimlanes, sub-processes,
or architectural boxes. Mark any node as a container with `.container()`, then
attach children with `.parent(containerId)`.

export const containerBuilder = viz().view(500, 340);
export const containerScene = containerBuilder
  .node('swim')
  .at(250, 170)
  .rect(460, 300)
  .label('Swimlane')
  .fill('#f0f4ff')
  .stroke('#4a6fa5', 2)
  .container({ headerHeight: 36 })
  .node('step1')
  .at(150, 220)
  .rect(100, 50)
  .label('Step 1')
  .parent('swim')
  .node('step2')
  .at(350, 220)
  .rect(100, 50)
  .label('Step 2')
  .parent('swim')
  .edge('step1', 'step2')
  .arrow()
  .done();

<CodePreview code={`
import { viz } from 'vizcraft';

const builder = viz().view(500, 340);

builder
.node('swim')
.at(250, 170)
.rect(460, 300)
.label('Swimlane')
.fill('#f0f4ff')
.stroke('#4a6fa5', 2)
.container({ headerHeight: 36 })
.node('step1')
.at(150, 220)
.rect(100, 50)
.label('Step 1')
.parent('swim')
.node('step2')
.at(350, 220)
.rect(100, 50)
.label('Step 2')
.parent('swim')
.edge('step1', 'step2')
.arrow()
.done();

const el = document.getElementById('viz-container');
if (el) builder.mount(el);
`}>

  <VizMount builder={containerScene} style={{ height: '340px', width: '100%' }} />
</CodePreview>

### How it works

| Builder method        | Effect                                                                        |
| --------------------- | ----------------------------------------------------------------------------- |
| `.container(config?)` | Marks the current node as a container. Accepts an optional `ContainerConfig`. |
| `.parent(id)`         | Makes the current node a child of the container with the given id.            |

**`ContainerConfig` options:**

- `layout` — `'free'` (default), `'vertical'`, or `'horizontal'`.
- `padding` — `{ top, right, bottom, left }` interior padding.
- `autoSize` — whether the container auto-resizes to fit children.
- `headerHeight` — height of the header band; renders a separator line and centres the container label in the header area.

Children's positions are specified in **absolute** scene coordinates. When a container moves at runtime (via `patchRuntime`), all its children are automatically offset by the same delta.

In the rendered SVG:

- Container nodes receive the `viz-container` CSS class.
- Children are nested inside a `<g class="viz-container-children">` group.
- The header line has the class `viz-container-header`.
